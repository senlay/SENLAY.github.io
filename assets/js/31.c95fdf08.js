(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{275:function(e,n,t){"use strict";t.r(n);var a=t(0),l=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("####提出问题？")]),e._v(" "),t("blockquote",[t("p",[e._v("多个线程访问同一个贡献变量时，可能出现线程同步，死锁等问题。\n如何解决多个线程同时操作同一共享变量呢?\n可以采用 "),t("font",{attrs:{color:"red"}},[e._v(" ThreadLocal 和 InheritableThreadLocal ")])],1)]),e._v(" "),t("ul",[t("li",[e._v("1，ThreadLocal")])]),e._v(" "),t("blockquote",[t("p",[e._v("当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本\nThreadLocal在java.lang包下。有个子类InheritableThreadLocal。\n假设ThreadA，ThreadB；成员变量tLocals。\nThreadA访问tLocals，首先将tLocals拷贝到线程本地的threadLocals中，threadLocals是一个map，它的键保存的是tLocals所指向的实例地址，它的值保存的就是tLocals.set(设置的值)")])]),e._v(" "),t("ul",[t("li",[t("p",[e._v("说明：")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("（1）可以自定义一个ThreadLocal子类，然后重写initialValue()，这样在第一次get()返回的就不是null")])]),e._v(" "),t("li",[t("p",[e._v("（2）常用方法：get()  、set(..)  、remove()")])])])]),e._v(" "),t("li",[t("p",[e._v("2，InheritableThreadLocal")])])]),e._v(" "),t("blockquote",[t("p",[e._v("ThreadLocal定义的变量，子线程不能获取其中的值\n但是采用InheritableThreadLocal可以实现。")])]),e._v(" "),t("ul",[t("li",[e._v("InheritableThreadLocal继承ThreadLocal，内部也维护了一个map,childValue方法维护主线程与子线程共享一个ThreadLocal")])]),e._v(" "),t("blockquote",[t("pre",[t("code",[e._v("protected T childValue(T parentValue) {\n     return parentValue;\n }\n")])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('private static ThreadLocal<String> tl2 = new InheritableThreadLocal<>();\n\npublic static void main(String[] args) throws InterruptedException {\n\n/**\n* 注：父线程的InheritableThreadLocal的设值，需要写在线程定义之前\n* 否则在子线程中的获取值就为null\n*/\ntl2.set("qwqw");\n\nThread t = new Thread() {\n\npublic void run() {\n\ntry {\n\nThread.sleep(1000);\n\n} catch (InterruptedException e) {\n\n// TODO Auto-generated catch block\ne.printStackTrace();\n\n}\nSystem.out.println("son thread tl2:" + tl2.get());\n\n};\n\n};\n\nt.start();\n\nSystem.out.println("main thread tl2:" + tl2.get());\n\n}\n\n\n\n打印结果：\n\nson thread tl2:qwqw\nmain thread tl2:qwqw\n\n')])])]),t("ul",[t("li",[t("p",[e._v("3，ThreadLocal的应用场景")]),e._v(" "),t("ul",[t("li",[e._v("（1）子线程需要使用存放在 threadlocal 变量中的用户登录信息，")]),e._v(" "),t("li",[e._v("（2）一些中间件需要把统一的 id 追踪的整个调用链路记录下来")])])]),e._v(" "),t("li",[t("p",[e._v("4，ThreadLocal的数据结构")])])]),e._v(" "),t("blockquote",[t("ul",[t("li",[e._v("内部维护了一个Map,即ThreadLocalMap")]),e._v(" "),t("li",[e._v("ThreadLocalMap用于存储每一个线程的变量副本，Map中元素的键为线程对象，而值对应线程的变量副本。")])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(' public T get() {\n        // 获取当前线程\n        Thread t = Thread.currentThread();\n        // 初始化 ThreadLocalMap\n        ThreadLocalMap map = getMap(t);\n        if (map != null) {\n            ThreadLocalMap.Entry e = map.getEntry(this);\n            if (e != null) {\n                @SuppressWarnings("unchecked")\n                T result = (T)e.value;\n                return result;\n            }\n        }\n        return setInitialValue();\n    }\n    \n      ThreadLocalMap getMap(Thread t) {\n            return t.threadLocals;\n        }\n        \n      private T setInitialValue() {\n            // 默认为空\n            T value = initialValue();\n            // 获取当前线程\n            Thread t = Thread.currentThread();\n            // 初始化ThreadLocalMap\n            ThreadLocalMap map = getMap(t);\n            if (map != null)\n                map.set(this, value);\n            else\n                createMap(t, value);\n            return value;\n        }\n        \n       // 首先通过getMap(Thread t)方法获取一个和当前线程相关的ThreadLocalMap，\n      //然后将变量的值设置到这个ThreadLocalMap对象中，当然如果获取到的ThreadLocalMap对象为空，就通过createMap方法创建。 \n        public void set(T value) {\n              Thread t = Thread.currentThread();\n              // 根据当前线程获取一个ThreadLocalMap，即每个线程都会有自己的ThreadLocalMap\n              ThreadLocalMap map = getMap(t);\n              // 如果ThreadLocalMap不为空，则将ThreadLocal对象和值设置到map中去，否真创建一个\n              if (map != null)\n                  map.set(this, value);\n              else\n                  createMap(t, value);\n          }      \n\n')])])]),t("ul",[t("li",[e._v("ThreadLocalMap源码")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('\n// ThreadLocalMap是ThreadLocal类的一个静态内部类，它实现了键值对的设置和获取，\n// 每个线程中都有一个独立的ThreadLocalMap副本，它所存储的值，只能被当前线程读取和修改。\n// ThreadLocal类通过操作每一个线程特有的ThreadLocalMap副本，从而实现了变量访问在不同线程中的隔离。\n// 因为每个线程的变量都是自己特有的，完全不会有并发错误。还有一点就是，\n// ThreadLocalMap存储的键值对中的键是this对象指向的ThreadLocal对象，而值就是所设置的对象\nstatic class ThreadLocalMap {\n\n        /**\n         * The entries in this hash map extend WeakReference, using\n         * its main ref field as the key (which is always a\n         * ThreadLocal object).  Note that null keys (i.e. entry.get()\n         * == null) mean that the key is no longer referenced, so the\n         * entry can be expunged from table.  Such entries are referred to\n         * as "stale entries" in the code that follows.\n         */\n        static class Entry extends WeakReference<ThreadLocal<?>> {\n            /** The value associated with this ThreadLocal. */\n            Object value;\n\n            Entry(ThreadLocal<?> k, Object v) {\n                super(k);\n                value = v;\n            }\n        }\n\n        /**\n         * The initial capacity -- MUST be a power of two.\n         */\n        private static final int INITIAL_CAPACITY = 16;\n\n        /**\n         * The table, resized as necessary.\n         * table.length MUST always be a power of two.\n         */\n        private Entry[] table;\n\n        /**\n         * The number of entries in the table.\n         */\n        private int size = 0;\n\n        /**\n         * The next size value at which to resize.\n         */\n        private int threshold; // Default to 0\n\n        /**\n         * Set the resize threshold to maintain at worst a 2/3 load factor.\n         */\n        private void setThreshold(int len) {\n            threshold = len * 2 / 3;\n        }\n\n        /**\n         * Increment i modulo len.\n         */\n        private static int nextIndex(int i, int len) {\n            return ((i + 1 < len) ? i + 1 : 0);\n        }\n\n        /**\n         * Decrement i modulo len.\n         */\n        private static int prevIndex(int i, int len) {\n            return ((i - 1 >= 0) ? i - 1 : len - 1);\n        }\n\n        /**\n         * Construct a new map initially containing (firstKey, firstValue).\n         * ThreadLocalMaps are constructed lazily, so we only create\n         * one when we have at least one entry to put in it.\n         */\n        ThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {\n            table = new Entry[INITIAL_CAPACITY];\n            int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1);\n            table[i] = new Entry(firstKey, firstValue);\n            size = 1;\n            setThreshold(INITIAL_CAPACITY);\n        }\n\n        /**\n         * Construct a new map including all Inheritable ThreadLocals\n         * from given parent map. Called only by createInheritedMap.\n         *\n         * @param parentMap the map associated with parent thread.\n         */\n        private ThreadLocalMap(ThreadLocalMap parentMap) {\n            Entry[] parentTable = parentMap.table;\n            int len = parentTable.length;\n            setThreshold(len);\n            table = new Entry[len];\n\n            for (int j = 0; j < len; j++) {\n                Entry e = parentTable[j];\n                if (e != null) {\n                    @SuppressWarnings("unchecked")\n                    ThreadLocal<Object> key = (ThreadLocal<Object>) e.get();\n                    if (key != null) {\n                        Object value = key.childValue(e.value);\n                        Entry c = new Entry(key, value);\n                        int h = key.threadLocalHashCode & (len - 1);\n                        while (table[h] != null)\n                            h = nextIndex(h, len);\n                        table[h] = c;\n                        size++;\n                    }\n                }\n            }\n        }\n\n        /**\n         * Get the entry associated with key.  This method\n         * itself handles only the fast path: a direct hit of existing\n         * key. It otherwise relays to getEntryAfterMiss.  This is\n         * designed to maximize performance for direct hits, in part\n         * by making this method readily inlinable.\n         *\n         * @param  key the thread local object\n         * @return the entry associated with key, or null if no such\n         */\n        private Entry getEntry(ThreadLocal<?> key) {\n            int i = key.threadLocalHashCode & (table.length - 1);\n            Entry e = table[i];\n            if (e != null && e.get() == key)\n                return e;\n            else\n                return getEntryAfterMiss(key, i, e);\n        }\n\n        /**\n         * Version of getEntry method for use when key is not found in\n         * its direct hash slot.\n         *\n         * @param  key the thread local object\n         * @param  i the table index for key\'s hash code\n         * @param  e the entry at table[i]\n         * @return the entry associated with key, or null if no such\n         */\n        private Entry getEntryAfterMiss(ThreadLocal<?> key, int i, Entry e) {\n            Entry[] tab = table;\n            int len = tab.length;\n\n            while (e != null) {\n                ThreadLocal<?> k = e.get();\n                if (k == key)\n                    return e;\n                if (k == null)\n                    expungeStaleEntry(i);\n                else\n                    i = nextIndex(i, len);\n                e = tab[i];\n            }\n            return null;\n        }\n\n        /**\n         * Set the value associated with key.\n         *\n         * @param key the thread local object\n         * @param value the value to be set\n         */\n        private void set(ThreadLocal<?> key, Object value) {\n\n            // We don\'t use a fast path as with get() because it is at\n            // least as common to use set() to create new entries as\n            // it is to replace existing ones, in which case, a fast\n            // path would fail more often than not.\n\n            Entry[] tab = table;\n            int len = tab.length;\n            int i = key.threadLocalHashCode & (len-1);\n\n            for (Entry e = tab[i];\n                 e != null;\n                 e = tab[i = nextIndex(i, len)]) {\n                ThreadLocal<?> k = e.get();\n\n                if (k == key) {\n                    e.value = value;\n                    return;\n                }\n\n                if (k == null) {\n                    replaceStaleEntry(key, value, i);\n                    return;\n                }\n            }\n\n            tab[i] = new Entry(key, value);\n            int sz = ++size;\n            if (!cleanSomeSlots(i, sz) && sz >= threshold)\n                rehash();\n        }\n\n        /**\n         * Remove the entry for key.\n         */\n        private void remove(ThreadLocal<?> key) {\n            Entry[] tab = table;\n            int len = tab.length;\n            int i = key.threadLocalHashCode & (len-1);\n            for (Entry e = tab[i];\n                 e != null;\n                 e = tab[i = nextIndex(i, len)]) {\n                if (e.get() == key) {\n                    e.clear();\n                    expungeStaleEntry(i);\n                    return;\n                }\n            }\n        }\n\n        /**\n         * Replace a stale entry encountered during a set operation\n         * with an entry for the specified key.  The value passed in\n         * the value parameter is stored in the entry, whether or not\n         * an entry already exists for the specified key.\n         *\n         * As a side effect, this method expunges all stale entries in the\n         * "run" containing the stale entry.  (A run is a sequence of entries\n         * between two null slots.)\n         *\n         * @param  key the key\n         * @param  value the value to be associated with key\n         * @param  staleSlot index of the first stale entry encountered while\n         *         searching for key.\n         */\n        private void replaceStaleEntry(ThreadLocal<?> key, Object value,\n                                       int staleSlot) {\n            Entry[] tab = table;\n            int len = tab.length;\n            Entry e;\n\n            // Back up to check for prior stale entry in current run.\n            // We clean out whole runs at a time to avoid continual\n            // incremental rehashing due to garbage collector freeing\n            // up refs in bunches (i.e., whenever the collector runs).\n            int slotToExpunge = staleSlot;\n            for (int i = prevIndex(staleSlot, len);\n                 (e = tab[i]) != null;\n                 i = prevIndex(i, len))\n                if (e.get() == null)\n                    slotToExpunge = i;\n\n            // Find either the key or trailing null slot of run, whichever\n            // occurs first\n            for (int i = nextIndex(staleSlot, len);\n                 (e = tab[i]) != null;\n                 i = nextIndex(i, len)) {\n                ThreadLocal<?> k = e.get();\n\n                // If we find key, then we need to swap it\n                // with the stale entry to maintain hash table order.\n                // The newly stale slot, or any other stale slot\n                // encountered above it, can then be sent to expungeStaleEntry\n                // to remove or rehash all of the other entries in run.\n                if (k == key) {\n                    e.value = value;\n\n                    tab[i] = tab[staleSlot];\n                    tab[staleSlot] = e;\n\n                    // Start expunge at preceding stale entry if it exists\n                    if (slotToExpunge == staleSlot)\n                        slotToExpunge = i;\n                    cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);\n                    return;\n                }\n\n                // If we didn\'t find stale entry on backward scan, the\n                // first stale entry seen while scanning for key is the\n                // first still present in the run.\n                if (k == null && slotToExpunge == staleSlot)\n                    slotToExpunge = i;\n            }\n\n            // If key not found, put new entry in stale slot\n            tab[staleSlot].value = null;\n            tab[staleSlot] = new Entry(key, value);\n\n            // If there are any other stale entries in run, expunge them\n            if (slotToExpunge != staleSlot)\n                cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);\n        }\n\n        /**\n         * Expunge a stale entry by rehashing any possibly colliding entries\n         * lying between staleSlot and the next null slot.  This also expunges\n         * any other stale entries encountered before the trailing null.  See\n         * Knuth, Section 6.4\n         *\n         * @param staleSlot index of slot known to have null key\n         * @return the index of the next null slot after staleSlot\n         * (all between staleSlot and this slot will have been checked\n         * for expunging).\n         */\n        private int expungeStaleEntry(int staleSlot) {\n            Entry[] tab = table;\n            int len = tab.length;\n\n            // expunge entry at staleSlot\n            tab[staleSlot].value = null;\n            tab[staleSlot] = null;\n            size--;\n\n            // Rehash until we encounter null\n            Entry e;\n            int i;\n            for (i = nextIndex(staleSlot, len);\n                 (e = tab[i]) != null;\n                 i = nextIndex(i, len)) {\n                ThreadLocal<?> k = e.get();\n                if (k == null) {\n                    e.value = null;\n                    tab[i] = null;\n                    size--;\n                } else {\n                    int h = k.threadLocalHashCode & (len - 1);\n                    if (h != i) {\n                        tab[i] = null;\n\n                        // Unlike Knuth 6.4 Algorithm R, we must scan until\n                        // null because multiple entries could have been stale.\n                        while (tab[h] != null)\n                            h = nextIndex(h, len);\n                        tab[h] = e;\n                    }\n                }\n            }\n            return i;\n        }\n\n        /**\n         * Heuristically scan some cells looking for stale entries.\n         * This is invoked when either a new element is added, or\n         * another stale one has been expunged. It performs a\n         * logarithmic number of scans, as a balance between no\n         * scanning (fast but retains garbage) and a number of scans\n         * proportional to number of elements, that would find all\n         * garbage but would cause some insertions to take O(n) time.\n         *\n         * @param i a position known NOT to hold a stale entry. The\n         * scan starts at the element after i.\n         *\n         * @param n scan control: {@code log2(n)} cells are scanned,\n         * unless a stale entry is found, in which case\n         * {@code log2(table.length)-1} additional cells are scanned.\n         * When called from insertions, this parameter is the number\n         * of elements, but when from replaceStaleEntry, it is the\n         * table length. (Note: all this could be changed to be either\n         * more or less aggressive by weighting n instead of just\n         * using straight log n. But this version is simple, fast, and\n         * seems to work well.)\n         *\n         * @return true if any stale entries have been removed.\n         */\n        private boolean cleanSomeSlots(int i, int n) {\n            boolean removed = false;\n            Entry[] tab = table;\n            int len = tab.length;\n            do {\n                i = nextIndex(i, len);\n                Entry e = tab[i];\n                if (e != null && e.get() == null) {\n                    n = len;\n                    removed = true;\n                    i = expungeStaleEntry(i);\n                }\n            } while ( (n >>>= 1) != 0);\n            return removed;\n        }\n\n        /**\n         * Re-pack and/or re-size the table. First scan the entire\n         * table removing stale entries. If this doesn\'t sufficiently\n         * shrink the size of the table, double the table size.\n         */\n        private void rehash() {\n            expungeStaleEntries();\n\n            // Use lower threshold for doubling to avoid hysteresis\n            if (size >= threshold - threshold / 4)\n                resize();\n        }\n\n        /**\n         * Double the capacity of the table.\n         */\n        private void resize() {\n            Entry[] oldTab = table;\n            int oldLen = oldTab.length;\n            int newLen = oldLen * 2;\n            Entry[] newTab = new Entry[newLen];\n            int count = 0;\n\n            for (int j = 0; j < oldLen; ++j) {\n                Entry e = oldTab[j];\n                if (e != null) {\n                    ThreadLocal<?> k = e.get();\n                    if (k == null) {\n                        e.value = null; // Help the GC\n                    } else {\n                        int h = k.threadLocalHashCode & (newLen - 1);\n                        while (newTab[h] != null)\n                            h = nextIndex(h, newLen);\n                        newTab[h] = e;\n                        count++;\n                    }\n                }\n            }\n\n            setThreshold(newLen);\n            size = count;\n            table = newTab;\n        }\n\n        /**\n         * Expunge all stale entries in the table.\n         */\n        private void expungeStaleEntries() {\n            Entry[] tab = table;\n            int len = tab.length;\n            for (int j = 0; j < len; j++) {\n                Entry e = tab[j];\n                if (e != null && e.get() == null)\n                    expungeStaleEntry(j);\n            }\n        }\n    }\n')])])])])}),[],!1,null,null,null);n.default=l.exports}}]);