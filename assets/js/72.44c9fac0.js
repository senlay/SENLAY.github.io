(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{316:function(t,n,e){"use strict";e.r(n);var o=e(0),r=Object(o.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h4",{attrs:{id:"spring-aop"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-aop","aria-hidden":"true"}},[t._v("#")]),t._v(" spring aop")]),t._v(" "),e("blockquote",[e("p",[t._v("aop 面向切面编程，动态的将业务逻辑进行横向切分，无任何侵入。比较好的例子有：日志记录、权限拦截、声明式事务等。\n日常开发中，我们经常会面临些各式各样的问题，比如：为了应对购物狂欢节对系统进行压力测试以便找到系统所能承受的最大压力和瓶颈，进而\n找出影响系统性能问题的原因。那么，进行压力测试我们势必要对整个系统进行代码修改，以符合压测环境的各项标准。\n就单系统而言，如果进行压测，假设我们直接在控制层加段开关逻辑，不进行资源处理也可以实现，虽然看起来难看但也可以实现。\n那么，如果是分布式系统，这样操作势必会让开发人员头皮发麻，而且冒得风险也比较大。对于这种情况，我们不想直接修改代码，想以更优雅的方式\n绕过一些资源处理，就可以采用AOP。我们可以对资源处理的类进行集中式的切面管理，直接绕过，并且可以通过配置的方式，类似U盘插拔一样。\nAOP让你可以使用简单可插拔的配置，在实际逻辑执行之前、之后或周围动态添加横切关注点。这让代码在当下和将来都变得易于维护。如果你是使用XML来使用切面的话，要添加或删除关注点，你不用重新编译完整的源代码，而仅仅需要修改配置文件就可以了。\nSpring AOP通过以下两种方式来使用。但是最广泛使用的方式是Spring AspectJ 注解风格(Spring AspectJ Annotation Style)")])]),t._v(" "),e("ul",[e("li",[t._v("使用AspectJ 注解风格")]),t._v(" "),e("li",[t._v("使用Spring XML 配置风格")])]),t._v(" "),e("h5",{attrs:{id:"spring-aop中关注点和横切关注点有什么不同？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-aop中关注点和横切关注点有什么不同？","aria-hidden":"true"}},[t._v("#")]),t._v(" Spring AOP中关注点和横切关注点有什么不同？")]),t._v(" "),e("ul",[e("li",[t._v("关注点是我们想在应用的模块中实现的行为，更多侧重的关注的行为")])]),t._v(" "),e("blockquote",[e("p",[t._v("关注点可以被定义为：我们想实现以解决特定业务问题的方法。比如，在所有电子商务应用中，不同的关注点（或者模块）可能是库存管理、航运管理、用户管理等。")])]),t._v(" "),e("ul",[e("li",[t._v("横切关注点是贯穿整个应用程序的关注点")])]),t._v(" "),e("blockquote",[e("p",[t._v("例如：日志、安全和数据转换，它们在应用的每一个模块都是必须的，所以他们是一种横切关注点。")])]),t._v(" "),e("h5",{attrs:{id:"spring-aop-代理是什么？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-aop-代理是什么？","aria-hidden":"true"}},[t._v("#")]),t._v(" spring AOP 代理是什么？")]),t._v(" "),e("blockquote",[e("p",[t._v("spring aop 是基于代理实现的，AOP 代理是一个由 AOP 框架创建的用于在运行时实现切面协议的对象。spring aop默认基于JDK动态代理实现，如果一个业务对象没有实现任何接口那么默认为CJLIB")])]),t._v(" "),e("h5",{attrs:{id:"aop常用api"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#aop常用api","aria-hidden":"true"}},[t._v("#")]),t._v(" AOP常用api")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("项")]),t._v(" "),e("th",[t._v("描述")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("Aspect")]),t._v(" "),e("td",[t._v("一个模块具有一组提供横切需求的 APIs。例如，一个日志模块为了记录日志将被 AOP 方面调用。应用程序可以拥有任意数量的方面，这取决于需求")])]),t._v(" "),e("tr",[e("td",[t._v("join Point")]),t._v(" "),e("td",[t._v("切面点，可以是一个方法 ,在 Spring AOP 中，一个连接点总是代表一个方法执行")])]),t._v(" "),e("tr",[e("td",[t._v("Advice")]),t._v(" "),e("td",[t._v("这是实际行动之前或之后执行的方法。这是在程序执行期间通过 Spring AOP 框架实际被调用的代码。")])]),t._v(" "),e("tr",[e("td",[t._v("Pointcut")]),t._v(" "),e("td",[t._v('这是一组一个或多个连接点，通知应该被执行。切入点(切入点)是一个匹配连接点的断言或者表达式。如@Pointcut("@annotation(com.pace.annotation.LoveForest)")。')])]),t._v(" "),e("tr",[e("td",[t._v("Introduction")]),t._v(" "),e("td",[t._v("引用允许你添加新方法或属性到现有的类中。")])]),t._v(" "),e("tr",[e("td",[t._v("Target object")]),t._v(" "),e("td",[t._v("被一个或者多个方面所通知的对象，这个对象永远是一个被代理对象。也称为被通知对象。")])]),t._v(" "),e("tr",[e("td",[t._v("Weaving（织入）")]),t._v(" "),e("td",[t._v("Weaving 把方面连接到其它的应用程序类型或者对象上，并创建一个被通知的对象。这些可以在编译时，类加载时和运行时完成。")])])])]),t._v(" "),e("h5",{attrs:{id:"通知的类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#通知的类型","aria-hidden":"true"}},[t._v("#")]),t._v(" 通知的类型")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("通知")]),t._v(" "),e("th",[t._v("描述")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("前置通知 before advice")]),t._v(" "),e("td",[t._v("在一个方法执行之前，执行通知。")])]),t._v(" "),e("tr",[e("td",[t._v("环绕通知 around advice")]),t._v(" "),e("td",[t._v("也叫增强通知，在建议方法调用之前和之后，执行通知")])]),t._v(" "),e("tr",[e("td",[t._v("后置通知 after advice")]),t._v(" "),e("td",[t._v("在一个方法执行之后，不考虑其结果，执行通知")])]),t._v(" "),e("tr",[e("td",[t._v("异常通知 After Throwing Advice")]),t._v(" "),e("td",[t._v("在一个方法执行之后，只有在方法退出抛出异常时，才能执行通知。")])]),t._v(" "),e("tr",[e("td",[t._v("返回后通知 after return advice")]),t._v(" "),e("td",[t._v("在一个方法执行之后，只有在方法成功完成时，才能执行通知")])])])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('package com.pace.aop;\n\nimport com.pace.annotation.LoveForest;\nimport org.aspectj.lang.JoinPoint;\nimport org.aspectj.lang.ProceedingJoinPoint;\nimport org.aspectj.lang.annotation.*;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.util.StringUtils;\nimport java.lang.reflect.Method;\n\n@Aspect\n@Configuration\npublic class MyAop {\n\n\n    //定义切点方法\n    @Pointcut("@annotation(com.pace.annotation.LoveForest)")\n    public void pointCut() {\n    }\n\n//    @Before("pointCut()")\n    public void beforeMethod(JoinPoint joinPoint) {\n        System.out.println("before method   start ..."+joinPoint.toString());\n\n        System.out.println("before method   end ...");\n    }\n\n\n\n    /**\n     * 环绕通知 around advice\n     * 这个切的是 com.pace.service 包下面以及子包下所有，后面又 && 同时满足带有注解 loveForest\n     */\n    @Around(value = "pointCut() && @annotation(loveForest)", argNames = "joinPoint, loveForest")\n    public Object methodAround(ProceedingJoinPoint joinPoint, LoveForest loveForest) throws Throwable {\n        System.out.println("Around method    start.......................");\n        //获得自定义注解的参数\n        System.out.println("Around method  methodLog 的参数，remark：" + loveForest.value() + " key：" + loveForest.key());\n        //执行目标方法，并获得对应方法的返回值\n        Object result = joinPoint.proceed();\n        System.out.println("Around method     返回结果：" + result);\n        System.out.println("Around method          end.......................");\n        return result;\n    }\n\n\n    /**\n     * 最终通知 after advice\n     * 使用的是在上面声明的切面，并且带上个注解，意思是除了满足上面pointCut()方法的条件还得带上注解才OK\n     */\n//    @After(value = "pointCut() && @annotation(loveForest)", argNames = "joinPoint, loveForest")\n    public void methodAfter(JoinPoint joinPoint, LoveForest loveForest) throws Throwable {\n        System.out.println("After method     start.......................");\n        //获得自定义注解的参数\n        System.out.println("After method   methodLog 的参数，remark：" + loveForest.value() + " key：" + loveForest.key());\n        LoveForest remark = getMethodRemark(joinPoint);\n        System.out.println("After method        end......................."+remark);\n    }\n\n    /**\n     * 获取方法的中文备注____用于记录用户的操作日志描述\n     */\n    private LoveForest getMethodRemark(JoinPoint joinPoint) throws Exception {\n        //返回目标对象\n        Object target = joinPoint.getTarget();\n        String targetName = target.getClass().getName();\n        //返回当前连接点签名\n        String methodName = joinPoint.getSignature().getName();\n        //获得参数列表\n        Object[] arguments = joinPoint.getArgs();\n\n        Class targetClass = Class.forName(targetName);\n        Method[] method = targetClass.getMethods();\n        for (Method m : method) {\n            if (m.getName().equals(methodName)) {\n                Class[] tmpCs = m.getParameterTypes();\n                if (tmpCs.length == arguments.length) {\n                    LoveForest methodCache = m.getAnnotation(LoveForest.class);\n                    if (methodCache != null && !StringUtils.isEmpty(methodCache)) {\n                        return methodCache;\n                    }\n                    break;\n                }\n            }\n        }\n        return null;\n    }\n\n\n    /**\n     * 后置异常通知\n     */\n//    @AfterThrowing("pointCut()")\n    public void afterThrows(JoinPoint jp){\n        System.out.println("方法异常时执行.....");\n    }\n\n\n}\n\n\n')])])])])}),[],!1,null,null,null);n.default=r.exports}}]);